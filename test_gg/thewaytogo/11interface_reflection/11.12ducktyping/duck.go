package main

import "fmt"

// 动态类型  这意味着对象可以根据提供的方法被处理（例如，作为参数传递给函数），而忽略它们的实际类型
// 整个设计可以持续演进，而不用废弃之前的决定。类型要实现某个接口，它本身不用改变，你只需要在这个类型上实现新的方法
// 在 Go 语言中函数重载可以用可变参数 ...T 作为函数最后一个参数来实现（参见 6.3 节）。
//如果我们把 T 换为空接口，那么可以知道任何类型的变量都是满足 T (空接口）类型的，这样就允许我们传递任何数量任何类型的参数给函数，即重载的实际含义

// 接口中显示的定义方法， 使用者则需要显示声明创建这些方法
//
//	type Fooer interface {
//		Foo()
//		ImplementsFooer()
//	}

// 接口的继承： 当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法

// Go 没有类，而是松耦合的类型、方法对接口的实现。
//
//OO 语言最重要的三个方面分别是：封装、继承和多态，在 Go 中它们是怎样表现的呢？
//
//封装（数据隐藏）：和别的 OO 语言有 4 个或更多的访问层次相比，Go 把它简化为了 2 层（参见 4.2 节的可见性规则）:
//
//1）包范围内的：通过标识符首字母小写，对象只在它所在的包内可见
//
//2）可导出的：通过标识符首字母大写，对象对所在包以外也可见
//
//类型只拥有自己所在包中定义的方法。
//
//继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现
//多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键

type IDuck interface {
	Quack()
	Walk()
}

func DuckDance(duck IDuck) {
	for i := 1; i <= 3; i++ {
		duck.Quack()
		duck.Walk()
	}
}

type Bird struct {
	// ...
}

func (b *Bird) Quack() {
	fmt.Println("I am quacking!")
}

func (b *Bird) Walk() {
	fmt.Println("I am walking!")
}

func Main() {
	b := new(Bird)
	DuckDance(b)
}
